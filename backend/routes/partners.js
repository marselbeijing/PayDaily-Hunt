const express = require('express');
const axios = require('axios');
const User = require('../models/User');
const Task = require('../models/Task');
const TaskCompletion = require('../models/TaskCompletion');

const router = express.Router();

// –ü–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ –æ—Ñ—Ñ–µ—Ä—ã –æ—Ç –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤
router.get('/offers', async (req, res) => {
    try {
        const { country = 'US', platform = 'mobile' } = req.query;
        
        const offers = [];
        
        // AdGem –æ—Ñ—Ñ–µ—Ä—ã
        if (process.env.ADGEM_API_KEY) {
            try {
                const adgemOffers = await getAdgemOffers(country, platform);
                offers.push(...adgemOffers);
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è AdGem –æ—Ñ—Ñ–µ—Ä–æ–≤:', error);
            }
        }
        
        // CPALead –æ—Ñ—Ñ–µ—Ä—ã
        if (process.env.CPALEAD_API_KEY) {
            try {
                const cpaleadOffers = await getCPALeadOffers(country, platform);
                offers.push(...cpaleadOffers);
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è CPALead –æ—Ñ—Ñ–µ—Ä–æ–≤:', error);
            }
        }
        
        // AdGate Media –æ—Ñ—Ñ–µ—Ä—ã
        if (process.env.ADGATE_API_KEY) {
            try {
                const adgateOffers = await getAdGateOffers(country, platform);
                offers.push(...adgateOffers);
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è AdGate –æ—Ñ—Ñ–µ—Ä–æ–≤:', error);
            }
        }
        
        // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –æ—Ñ—Ñ–µ—Ä–æ–≤ –≤ —Ñ–æ—Ä–º–∞—Ç –∑–∞–¥–∞–Ω–∏–π
        const tasks = offers.map(offer => convertOfferToTask(offer));
        
        res.json({
            success: true,
            offers: tasks,
            total: tasks.length
        });
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ñ—Ñ–µ—Ä–æ–≤:', error);
        res.status(500).json({ error: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    }
});

// –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –∫–ª–∏–∫–æ–≤ –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤
router.post('/track', async (req, res) => {
    try {
        const { 
            userId, 
            offerId, 
            partner, 
            clickId, 
            userAgent, 
            ip 
        } = req.body;
        
        // –°–æ–∑–¥–∞—Ç—å –∑–∞–ø–∏—Å—å –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
        const trackingData = {
            userId,
            offerId,
            partner,
            clickId,
            userAgent,
            ip,
            timestamp: new Date()
        };
        
        // –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏
        // await TrackingEvent.create(trackingData);
        
        // –û—Ç–ø—Ä–∞–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –ø–∞—Ä—Ç–Ω–µ—Ä—É
        let trackingUrl = '';
        
        switch (partner) {
            case 'adgem':
                trackingUrl = `https://adgem.com/api/track?click_id=${clickId}&offer_id=${offerId}`;
                break;
            case 'cpalead':
                trackingUrl = `https://cpalead.com/api/track?click_id=${clickId}&offer_id=${offerId}`;
                break;
            case 'adgate':
                trackingUrl = `https://adgatemedia.com/api/track?click_id=${clickId}&offer_id=${offerId}`;
                break;
        }
        
        if (trackingUrl) {
            await axios.post(trackingUrl, trackingData);
        }
        
        res.json({
            success: true,
            tracked: true
        });
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è:', error);
        res.status(500).json({ error: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    }
});

// Webhook –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–Ω–≤–µ—Ä—Å–∏–π –æ—Ç –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤
router.post('/callback/:partner', async (req, res) => {
    try {
        const { partner } = req.params;
        const callbackData = req.body;
        
        let completionId, status, rewardAmount;
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤ callback'–æ–≤
        switch (partner) {
            case 'adgem':
                completionId = callbackData.click_id;
                status = callbackData.status === 'approved' ? 'approved' : 'rejected';
                rewardAmount = parseFloat(callbackData.payout || 0);
                break;
                
            case 'cpalead':
                completionId = callbackData.subid;
                status = callbackData.status === '1' ? 'approved' : 'rejected';
                rewardAmount = parseFloat(callbackData.payout || 0);
                break;
                
            case 'adgate':
                completionId = callbackData.user_id;
                status = callbackData.status === 'credited' ? 'approved' : 'rejected';
                rewardAmount = parseFloat(callbackData.points || 0);
                break;
                
            default:
                return res.status(400).json({ error: '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø–∞—Ä—Ç–Ω–µ—Ä' });
        }
        
        // –ù–∞–π—Ç–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è –ø–æ tracking ID
        const completion = await TaskCompletion.findOne({
            'partnerTracking.clickId': completionId
        }).populate('user task');
        
        if (!completion) {
            return res.status(404).json({ error: '–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' });
        }
        
        // –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å
        completion.status = status;
        completion.verificationData.method = 'api_callback';
        completion.verificationData.verificationNotes = `Callback –æ—Ç ${partner}`;
        
        if (status === 'approved') {
            completion.completedAt = new Date();
            
            // –ù–∞—á–∏—Å–ª–∏—Ç—å –Ω–∞–≥—Ä–∞–¥—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            const user = completion.user;
            user.points += completion.rewardAmount;
            user.totalEarned += completion.rewardAmount;
            user.tasksCompleted += 1;
            user.updateVipLevel();
            
            await user.save();
            
            // –ë–æ–Ω—É—Å —Ä–µ—Ñ–µ—Ä–µ—Ä—É (–µ—Å–ª–∏ –µ—Å—Ç—å)
            if (user.referredBy) {
                const referrer = await User.findById(user.referredBy);
                if (referrer) {
                    const referralBonus = Math.floor(completion.rewardAmount * 0.1); // 10%
                    referrer.points += referralBonus;
                    referrer.referralEarnings += referralBonus;
                    await referrer.save();
                }
            }
        }
        
        await completion.save();
        
        // –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —á–µ—Ä–µ–∑ Telegram Bot
        if (status === 'approved') {
            // await sendTelegramNotification(completion.user.telegramId, 
            //     `üéâ –ó–∞–¥–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ! –ü–æ–ª—É—á–µ–Ω–æ ${completion.rewardAmount} –±–∞–ª–ª–æ–≤.`);
        }
        
        res.json({ success: true, status: 'processed' });
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ callback:', error);
        res.status(500).json({ error: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    }
});

// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–¥–∞–Ω–∏–π —Å –ø–∞—Ä—Ç–Ω–µ—Ä–∞–º–∏
router.post('/sync', async (req, res) => {
    try {
        const { partner, country = 'US' } = req.body;
        
        let offers = [];
        
        switch (partner) {
            case 'adgem':
                offers = await getAdgemOffers(country);
                break;
            case 'cpalead':
                offers = await getCPALeadOffers(country);
                break;
            case 'adgate':
                offers = await getAdGateOffers(country);
                break;
            default:
                return res.status(400).json({ error: '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø–∞—Ä—Ç–Ω–µ—Ä' });
        }
        
        let created = 0, updated = 0;
        
        for (const offer of offers) {
            const taskData = convertOfferToTask(offer);
            
            const existingTask = await Task.findOne({
                'partner.trackingId': offer.id,
                'partner.name': partner
            });
            
            if (existingTask) {
                await Task.updateOne({ _id: existingTask._id }, taskData);
                updated++;
            } else {
                await Task.create(taskData);
                created++;
            }
        }
        
        res.json({
            success: true,
            created,
            updated,
            total: offers.length
        });
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏:', error);
        res.status(500).json({ error: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    }
});

// –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ –ø–∞—Ä—Ç–Ω–µ—Ä–∞–º–∏

async function getAdgemOffers(country = 'US', platform = 'mobile') {
    try {
        const response = await axios.get('https://adgem.com/api/offers', {
            params: {
                api_key: process.env.ADGEM_API_KEY,
                country,
                platform,
                format: 'json'
            }
        });
        
        return response.data.offers || [];
    } catch (error) {
        console.error('AdGem API error:', error);
        return [];
    }
}

async function getCPALeadOffers(country = 'US', platform = 'mobile') {
    try {
        const response = await axios.get('https://cpalead.com/api/offers', {
            params: {
                api_key: process.env.CPALEAD_API_KEY,
                country,
                platform,
                format: 'json'
            }
        });
        
        return response.data.offers || [];
    } catch (error) {
        console.error('CPALead API error:', error);
        return [];
    }
}

async function getAdGateOffers(country = 'US', platform = 'mobile') {
    try {
        const response = await axios.get('https://adgatemedia.com/api/offers', {
            params: {
                api_key: process.env.ADGATE_API_KEY,
                country,
                platform,
                format: 'json'
            }
        });
        
        return response.data.offers || [];
    } catch (error) {
        console.error('AdGate API error:', error);
        return [];
    }
}

function convertOfferToTask(offer) {
    // –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–∏–ø –∑–∞–¥–∞–Ω–∏—è
    let type = 'registration';
    if (offer.name.toLowerCase().includes('video')) type = 'video';
    if (offer.name.toLowerCase().includes('survey')) type = 'survey';
    if (offer.name.toLowerCase().includes('install')) type = 'app_install';
    if (offer.name.toLowerCase().includes('follow') || offer.name.toLowerCase().includes('like')) type = 'social';
    
    // –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å–ª–æ–∂–Ω–æ—Å—Ç—å
    let difficulty = 'easy';
    if (offer.payout > 1) difficulty = 'medium';
    if (offer.payout > 5) difficulty = 'hard';
    
    return {
        title: offer.name,
        description: offer.description || offer.name,
        type,
        reward: Math.floor(offer.payout * 100), // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ –±–∞–ª–ª—ã
        difficulty,
        estimatedTime: offer.estimated_time || 5,
        actionUrl: offer.url,
        imageUrl: offer.image_url,
        partner: {
            name: offer.partner || 'unknown',
            apiEndpoint: offer.api_endpoint,
            trackingId: offer.id.toString(),
            conversionGoal: offer.conversion_goal
        },
        requirements: {
            countries: offer.countries || ['US'],
            deviceTypes: offer.device_types || ['mobile', 'desktop']
        },
        isActive: true,
        isPremium: offer.payout > 2,
        category: getCategoryFromOffer(offer)
    };
}

function getCategoryFromOffer(offer) {
    const name = offer.name.toLowerCase();
    if (name.includes('crypto') || name.includes('bitcoin')) return 'crypto';
    if (name.includes('game') || name.includes('play')) return 'gaming';
    if (name.includes('shop') || name.includes('buy')) return 'shopping';
    if (name.includes('learn') || name.includes('course')) return 'education';
    if (name.includes('watch') || name.includes('video')) return 'entertainment';
    return 'finance';
}

module.exports = router;